// SPDX-License-Identifier: MIT
pragma solidity ^0.8.28;

import { FHE, euint64, ebool, externalEbool } from "@fhevm/solidity/lib/FHE.sol";
import { SepoliaConfig } from "@fhevm/solidity/config/ZamaConfig.sol";
import { HCULimits } from "./HCULimits.sol";

/**
 * @title EncryptedVoting
 * @dev ä¸€ä¸ªä½¿ç”¨FHEVM 0.7.0å®ç°éšç§ä¿æŠ¤çš„æŠ•ç¥¨åˆçº¦
 * @notice æ‰€æœ‰æŠ•ç¥¨éƒ½æ˜¯åŠ å¯†çš„ï¼Œç»“æœåªæœ‰åœ¨æŠ•ç¥¨ç»“æŸåæ‰èƒ½é€šè¿‡è§£å¯†é¢„è¨€æœºè§£å¯†
 * 
 * FHEVM 0.7.0 æ›´æ–°:
 * - ç§»é™¤äº† ebytes ç±»å‹ï¼ˆå·²å¼ƒç”¨ï¼‰
 * - ä½¿ç”¨ HCU (åŒæ€å¤æ‚åº¦å•å…ƒ) æ›¿ä»£ gas é™åˆ¶
 * - æ¯ç¬”äº¤æ˜“çš„é¡ºåºæ“ä½œæ·±åº¦é™åˆ¶: 5,000,000 HCU
 * - æ¯ç¬”äº¤æ˜“çš„å…¨å±€æ“ä½œå¤æ‚åº¦é™åˆ¶: 20,000,000 HCU
 */
contract EncryptedVoting is SepoliaConfig {
    
    // æŠ•ç¥¨çŠ¶æ€æšä¸¾
    enum VotingStatus {
        Open,           // æŠ•ç¥¨è¿›è¡Œä¸­
        DecryptionInProgress,  // è§£å¯†è¿›è¡Œä¸­
        ResultsDecrypted       // ç»“æœå·²è§£å¯†
    }
    
    // çŠ¶æ€å˜é‡
    mapping(address => bool) public hasVoted;
    VotingStatus public status;
    
    // åŠ å¯†çš„æŠ•ç¥¨è®¡æ•°
    euint64 private encryptedYesVotes;
    euint64 private encryptedNoVotes;
    
    // è§£å¯†åçš„ç»“æœ
    uint64 public decryptedYesVotes;
    uint64 public decryptedNoVotes;
    
    // æ€»æŠ•ç¥¨æ•°è®¡æ•°å™¨ï¼ˆå…¬å¼€ï¼Œå®æ—¶æ›´æ–°ï¼‰
    uint256 public totalVotes;
    
    // æŠ•ç¥¨æˆªæ­¢æ—¶é—´
    uint256 public voteDeadline;
    
    // æŠ•ç¥¨ä¸»é¢˜
    string public votingTopic;
    
    // åˆçº¦æ‹¥æœ‰è€…
    address public owner;
    
    // äº‹ä»¶
    event VoteCasted(address indexed voter, uint256 totalVotes);
    event DecryptionRequested(uint256 requestId);
    event ResultsDecrypted(uint64 yesVotes, uint64 noVotes);
    event VotingCreated(string topic, uint256 deadline);
    
    modifier onlyOwner() {
        require(msg.sender == owner, "Only owner can call this function");
        _;
    }
    
    modifier votingOpen() {
        require(status == VotingStatus.Open, "Voting is not open");
        require(block.timestamp <= voteDeadline, "Voting deadline has passed");
        _;
    }
    
    /**
     * @dev æ„é€ å‡½æ•°
     * @param _topic æŠ•ç¥¨ä¸»é¢˜
     * @param _durationInHours æŠ•ç¥¨æŒç»­æ—¶é—´ï¼ˆå°æ—¶ï¼‰
     */
    constructor(string memory _topic, uint256 _durationInHours) {
        owner = msg.sender;
        votingTopic = _topic;
        voteDeadline = block.timestamp + (_durationInHours * 1 hours);
        status = VotingStatus.Open;
        
        // åˆå§‹åŒ–åŠ å¯†æŠ•ç¥¨è®¡æ•°ä¸º0
        encryptedYesVotes = FHE.asEuint64(0);
        encryptedNoVotes = FHE.asEuint64(0);
        
        // ğŸ†• å…è®¸åˆçº¦è®¿é—®åŠ å¯†å˜é‡ - æŒä¹…è®¿é—®æƒé™
        FHE.allowThis(encryptedYesVotes);
        FHE.allowThis(encryptedNoVotes);
        
        emit VotingCreated(_topic, voteDeadline);
    }
    
    /**
     * @dev æŠ•ç¥¨å‡½æ•°
     * @param support åŠ å¯†çš„æŠ•ç¥¨é€‰æ‹©ï¼ˆtrue=èµæˆï¼Œfalse=åå¯¹ï¼‰
     * @param inputProof é›¶çŸ¥è¯†è¯æ˜
     * @notice æ­¤æ“ä½œçš„ä¼°ç®— HCU æˆæœ¬çº¦ä¸º 8,000 HCU (åœ¨é™åˆ¶èŒƒå›´å†…)
     */
    function vote(externalEbool support, bytes memory inputProof) public votingOpen {
        require(!hasVoted[msg.sender], "You have already voted");
        
        // éªŒè¯ HCU æˆæœ¬åœ¨é™åˆ¶èŒƒå›´å†…
        uint256 estimatedCost = HCULimits.estimateVotingCost();
        require(
            HCULimits.isWithinSequentialLimit(estimatedCost) && 
            HCULimits.isWithinGlobalLimit(estimatedCost),
            "Operation exceeds HCU limits"
        );
        
        // æ ‡è®°ç”¨æˆ·å·²æŠ•ç¥¨å¹¶å¢åŠ æ€»æŠ•ç¥¨æ•°
        hasVoted[msg.sender] = true;
        totalVotes++;
        
        // å°†å¤–éƒ¨åŠ å¯†å¸ƒå°”å€¼è½¬æ¢ä¸ºå†…éƒ¨ç±»å‹
        ebool isSupport = FHE.fromExternal(support, inputProof);
        
        // ä½¿ç”¨FHE.selectè¿›è¡Œæ¡ä»¶åŠ æ³•ï¼šå¦‚æœæ”¯æŒåˆ™å¢åŠ yesVotesï¼Œå¦åˆ™å¢åŠ noVotes
        encryptedYesVotes = FHE.select(
            isSupport, 
            FHE.add(encryptedYesVotes, FHE.asEuint64(1)), 
            encryptedYesVotes
        );
        
        encryptedNoVotes = FHE.select(
            isSupport, 
            encryptedNoVotes, 
            FHE.add(encryptedNoVotes, FHE.asEuint64(1))
        );
        
        // ğŸ†• æ›´æ–°è®¿é—®æƒé™ - ä½¿ç”¨æŒä¹…è®¿é—®æ§åˆ¶
        FHE.allowThis(encryptedYesVotes);    // åˆçº¦æŒä¹…è®¿é—®
        FHE.allowThis(encryptedNoVotes);     // åˆçº¦æŒä¹…è®¿é—®
        
        // å¯é€‰ï¼šä¸ºæŠ•ç¥¨è€…æä¾›ä¸´æ—¶è®¿é—®ï¼ˆä»…åœ¨å½“å‰äº¤æ˜“ä¸­æœ‰æ•ˆï¼‰
        FHE.allowTransient(encryptedYesVotes, msg.sender);
        FHE.allowTransient(encryptedNoVotes, msg.sender);
        
        emit VoteCasted(msg.sender, totalVotes);
    }
    
    /**
     * @dev è¯·æ±‚è§£å¯†æŠ•ç¥¨ç»“æœ
     * @notice åªæœ‰åœ¨æŠ•ç¥¨ç»“æŸåæ‰èƒ½è°ƒç”¨
     * @notice æ­¤æ“ä½œçš„ä¼°ç®— HCU æˆæœ¬çº¦ä¸º 7,000 HCU (åœ¨é™åˆ¶èŒƒå›´å†…)
     */
    function requestVoteDecryption() public {
        require(block.timestamp > voteDeadline, "Voting is still in progress");
        require(status == VotingStatus.Open, "Decryption already requested or completed");
        
        // éªŒè¯è§£å¯†æ“ä½œçš„ HCU æˆæœ¬
        uint256 estimatedCost = HCULimits.estimateDecryptionCost(2); // 2ä¸ªå€¼éœ€è¦è§£å¯†
        require(
            HCULimits.isWithinSequentialLimit(estimatedCost) && 
            HCULimits.isWithinGlobalLimit(estimatedCost),
            "Decryption operation exceeds HCU limits"
        );
        
        // å‡†å¤‡è¦è§£å¯†çš„å¯†æ–‡æ•°ç»„
        bytes32[] memory cts = new bytes32[](2);
        cts[0] = FHE.toBytes32(encryptedYesVotes);
        cts[1] = FHE.toBytes32(encryptedNoVotes);
        
        // è¯·æ±‚è§£å¯†
        uint256 requestId = FHE.requestDecryption(cts, this.callbackDecryptVotes.selector);
        status = VotingStatus.DecryptionInProgress;
        
        emit DecryptionRequested(requestId);
    }
    
    /**
     * @dev è§£å¯†å›è°ƒå‡½æ•°
     * @param requestId è¯·æ±‚ID
     * @param yesVotes è§£å¯†åçš„èµæˆç¥¨æ•°
     * @param noVotes è§£å¯†åçš„åå¯¹ç¥¨æ•°  
     * @param signatures ç­¾åæ•°ç»„ç”¨äºéªŒè¯
     */
    function callbackDecryptVotes(
        uint256 requestId, 
        uint64 yesVotes, 
        uint64 noVotes, 
        bytes[] memory signatures
    ) public {
        // éªŒè¯ç­¾å
        FHE.checkSignatures(requestId, signatures);
        
        // å­˜å‚¨è§£å¯†ç»“æœ
        decryptedYesVotes = yesVotes;
        decryptedNoVotes = noVotes;
        status = VotingStatus.ResultsDecrypted;
        
        emit ResultsDecrypted(yesVotes, noVotes);
    }
    
    /**
     * @dev è·å–æŠ•ç¥¨ç»“æœ
     * @return yesVotes èµæˆç¥¨æ•°
     * @return noVotes åå¯¹ç¥¨æ•°
     */
    function getResults() public view returns (uint64 yesVotes, uint64 noVotes) {
        require(status == VotingStatus.ResultsDecrypted, "Results have not been decrypted yet");
        return (decryptedYesVotes, decryptedNoVotes);
    }
    
    /**
     * @dev è·å–æŠ•ç¥¨åŸºæœ¬ä¿¡æ¯
     */
    function getVotingInfo() public view returns (
        string memory topic,
        uint256 deadline,
        VotingStatus currentStatus,
        bool userHasVoted,
        uint256 totalVoteCount
    ) {
        return (
            votingTopic,
            voteDeadline,
            status,
            hasVoted[msg.sender],
            totalVotes
        );
    }
    
    /**
     * @dev æ£€æŸ¥æŠ•ç¥¨æ˜¯å¦ä»åœ¨è¿›è¡Œä¸­
     */
    function isVotingActive() public view returns (bool) {
        return status == VotingStatus.Open && block.timestamp <= voteDeadline;
    }
    
    /**
     * @dev è·å–å‰©ä½™æŠ•ç¥¨æ—¶é—´ï¼ˆç§’ï¼‰
     */
    function getTimeLeft() public view returns (uint256) {
        if (block.timestamp >= voteDeadline) {
            return 0;
        }
        return voteDeadline - block.timestamp;
    }
    
    /**
     * @dev ç´§æ€¥åœæ­¢æŠ•ç¥¨ï¼ˆä»…æ‹¥æœ‰è€…ï¼‰
     */
    function emergencyStop() public onlyOwner {
        require(status == VotingStatus.Open, "Voting is not open");
        voteDeadline = block.timestamp;
    }
    
    /**
     * @dev æ›´æ–°æŠ•ç¥¨æˆªæ­¢æ—¶é—´ï¼ˆä»…æ‹¥æœ‰è€…ï¼‰
     * @param newDeadline æ–°çš„æˆªæ­¢æ—¶é—´æˆ³
     */
    function updateVotingDeadline(uint256 newDeadline) public onlyOwner {
        require(status == VotingStatus.Open, "Voting is not open");
        require(newDeadline > block.timestamp, "New deadline must be in the future");
        voteDeadline = newDeadline;
    }
    
    /**
     * @dev è®¾ç½®æŠ•ç¥¨æˆªæ­¢æ—¶é—´ä¸º10æœˆ1æ—¥
     */
    function setDeadlineToOctober1st() public onlyOwner {
        // 2025å¹´10æœˆ1æ—¥ 23:59:59 UTC çš„æ—¶é—´æˆ³
        uint256 october1st2025 = 1759363199; // 2025-10-01 23:59:59 UTC
        voteDeadline = october1st2025;
        
        // å¦‚æœæŠ•ç¥¨å·²ç»ç»“æŸï¼Œé‡ç½®çŠ¶æ€ä¸ºè¿›è¡Œä¸­
        if (status != VotingStatus.Open) {
            status = VotingStatus.Open;
        }
    }
    
    /**
     * @dev é‡ç½®æŠ•ç¥¨çŠ¶æ€ä¸ºè¿›è¡Œä¸­ï¼ˆä»…æ‹¥æœ‰è€…ï¼‰
     */
    function resetVotingStatus() public onlyOwner {
        status = VotingStatus.Open;
        // æ¸…é™¤è§£å¯†ç»“æœ
        decryptedYesVotes = 0;
        decryptedNoVotes = 0;
        // å»¶é•¿æŠ•ç¥¨æ—¶é—´24å°æ—¶ä»¥ç¡®ä¿å¯ä»¥æŠ•ç¥¨
        voteDeadline = block.timestamp + 24 hours;
    }
    
    /**
     * @dev å®Œå…¨é‡ç½®æŠ•ç¥¨ï¼ˆæ—¶é—´å’ŒçŠ¶æ€ï¼‰
     */
    function resetVotingCompletely() public onlyOwner {
        status = VotingStatus.Open;
        decryptedYesVotes = 0;
        decryptedNoVotes = 0;
        // è®¾ç½®ä¸º2025å¹´10æœˆ1æ—¥
        voteDeadline = 1759363199; // 2025-10-01 23:59:59 UTC
    }
    
    /**
     * @dev è·å–åˆçº¦çš„åŸºæœ¬ç»Ÿè®¡ä¿¡æ¯ï¼ˆä¸åŒ…å«åŠ å¯†ç»“æœï¼‰
     */
    function getStats() public view returns (
        uint256 totalVoters,
        uint256 timeRemaining,
        bool active
    ) {
        // æ³¨æ„ï¼šæˆ‘ä»¬æ— æ³•è¿”å›å®é™…æŠ•ç¥¨æ•°ï¼Œå› ä¸ºå®ƒä»¬æ˜¯åŠ å¯†çš„
        return (
            0, // æ— æ³•è®¡ç®—æ€»æŠ•ç¥¨æ•°ï¼Œå› ä¸ºæˆ‘ä»¬æ— æ³•è®¿é—®åŠ å¯†æ•°æ®
            getTimeLeft(),
            isVotingActive()
        );
    }
    
    /**
     * @dev è·å– FHEVM 0.7.0 HCU é™åˆ¶ä¿¡æ¯
     * @return sequentialLimit é¡ºåºæ“ä½œ HCU é™åˆ¶
     * @return globalLimit å…¨å±€æ“ä½œ HCU é™åˆ¶
     * @return votingCost æŠ•ç¥¨æ“ä½œçš„ä¼°ç®— HCU æˆæœ¬
     * @return decryptionCost è§£å¯†æ“ä½œçš„ä¼°ç®— HCU æˆæœ¬
     */
    function getHCUInfo() public pure returns (
        uint256 sequentialLimit,
        uint256 globalLimit,
        uint256 votingCost,
        uint256 decryptionCost
    ) {
        (sequentialLimit, globalLimit) = HCULimits.getLimits();
        votingCost = HCULimits.estimateVotingCost();
        decryptionCost = HCULimits.estimateDecryptionCost(2);
    }
    
    /**
     * @dev ğŸ†• éªŒè¯å‘é€è€…å¯¹æŠ•ç¥¨æ•°æ®çš„è®¿é—®æƒé™
     * @return canAccessYes æ˜¯å¦å¯ä»¥è®¿é—®èµæˆç¥¨æ•°æ®
     * @return canAccessNo æ˜¯å¦å¯ä»¥è®¿é—®åå¯¹ç¥¨æ•°æ®
     */
    function verifyVoteAccess() external view returns (bool canAccessYes, bool canAccessNo) {
        canAccessYes = FHE.isSenderAllowed(encryptedYesVotes);
        canAccessNo = FHE.isSenderAllowed(encryptedNoVotes);
    }
    
    /**
     * @dev ğŸ†• ä¸ºç‰¹å®šç”¨æˆ·æˆäºˆæŠ•ç¥¨æ•°æ®çš„è®¿é—®æƒé™ï¼ˆä»…æ‹¥æœ‰è€…ï¼‰
     * @param user è¦æˆæƒçš„ç”¨æˆ·åœ°å€
     */
    function grantVoteAccess(address user) external onlyOwner {
        FHE.allow(encryptedYesVotes, user);
        FHE.allow(encryptedNoVotes, user);
    }
}